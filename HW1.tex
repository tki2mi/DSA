\documentclass[12pt]{article}
\usepackage[margin=1.5cm]{geometry}
\usepackage{xurl}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{xeCJK}
\setCJKmainfont{NotoSerifTC-Regular.otf}
\title{Data Structure and Algorithm HW1}
\author{R11522709 機械所\, 碩一\, 石翊鵬}
\begin{document}
\maketitle
\section*{1. What if you became a DSA TA?}
\subsection*{Proof of conjecture 1}
Consider $f(n)\geq 0$ and $g(n) \geq 0$ that $\lim_{n \to \infty} {\frac{f(n)}{g(n)}} = c$, where $c \in R$\newline
To prove $\lim_{n \to \infty} {\frac{f(n)}{g(n)}} \geq 0$ for all $n \in R$, we can consider h(n) = 0\newline
Since \(f(n) \geq 0\) and \(g(n) \geq 0 \) for all \(n\in R\), \(\frac{f(n)}{g(n)} \geq h(n)\) for all \(n\)\newline
therefore,
\[\lim_{n \to \infty}{h(n)}\geq \lim_{n \to \infty} {\frac{f(n)}{g(n)}}\]
\[\lim_{n \to \infty}{h(n)} = 0 \Rightarrow \lim_{n \to \infty} {\frac{f(n)}{g(n)}}=c \geq 0\]
By difinition of limit, there exists $\epsilon > 0$, $n_0 > 0$ such that for all $n > n_0$, \newline
\[|\frac{f(n)}{g(n)}-c|<\epsilon\]
\[-\epsilon < \frac{f(n)}{g(n)} -c < \epsilon\]
\[-\epsilon + c < \frac{f(n)}{g(n)} < \epsilon + c \]
In case that $0 < c < \epsilon$
\[-\epsilon + c < 0 < \frac{f(n)}{g(n)} < \epsilon + c \]
In case that $c \geq \epsilon$
\[0 \leq -\epsilon + c < \frac{f(n)}{g(n)} < \epsilon + c \]
\[0 \leq f(n) < (\epsilon + c)g(n)\]
Let $(\epsilon + c) = c_1$
\[0 \leq f(n) \leq c_1g(n)\]
which shows $f(n) = O(g(n))$, QED
\subsection*{1.1 - all by myself}
Consider $c_1, c_2 >0$\
for all $n > 0$\newline
if
\[\frac{c_1}{c_2}n \geq 1\]
then
\[c_1n^3\geq c_2n^2\]
let
\[n_0 = \frac{c_2}{c_1}\]
\[\frac{c_1}{c_2}n_0 = 1\]
consider $k > 0$
\[\frac{c_1}{c_2}(n_0+k) = 1+\frac{c_1}{c_2}k\]
where
\[\frac{c_1}{c_2}k > 0\]
that is, for all $n \geq n_0$,
\[0\leq c_2n^2 \leq c_1n^3\]
therefore, if
\[0 \leq f(x) \leq c_3n^2\]
for all $n > n_1$ where $n_1, c_3 > 0$\newline
then
\[0 \leq f(n) \leq c_3n^2 \leq \frac{c_3c_1}{c_2}n^3\]
for all $n > max(n_0, n_1)$, QED
\subsection*{1-2 - all by myself}
Let $t_m = the\ number\ of\ while\ checks$, $k = the\ index\ of\ key$, $d_n = time cost of each line to execute once$\newline
Since the value of m is assigned to l in the beginning of each while loop, m will start from 1 and increase by 1 when while loop is executed once, moreover, $A[m] \leq key$ will always be satisfied.\newline
therefore,
\[t_m = k\]
in worst case, key is not in the array, in this case
\[T(n) = d_1n + d_2(n-1) + d_3(n-1) + d_4 * 0 + d_5(n-1) + d_6 * 0 + d_7(n-1) + d_8(n-1) + d_9\]
\[T(n) = c_1n + c_2\]
where $c_1$, $c_2 > 0$
\[\lim_{n \to \infty} {\frac{c_1n + c_2}{n}} = c_1\]
By conjecture 1, time complexity of the algorithm is $O(n)$

\subsection*{1-3}
ref: \url{https://math.stackexchange.com/questions/925053/using-limits-to-determine-big-o-big-omega-and-big-theta#comment6149810_925053}\newline
\[f(n)=\Theta(n^2)\Longleftrightarrow there\ exists\ positive\ (n_0, c_1, c_2)\ such\ that\ c_1n^2\leq f(n)\leq c_2n^2\ for\ all\ n\geq n_0\]
Let \(c_1 = 1\), \(c_2 = 10\) and \(f(n) = n^2(sin(n) + 2) + n\)\newline
for all \(n > 0\), \(n^2  \leq f(n) \leq 10n^2\)\newline
Suppose
\[\lim_{n \to \infty} {f(n)} = L\]
where $L \in R$, then there exist $\epsilon > 0$, $n > 0$ such that for all $n > n_0$,
\[|f(n)-L|<\epsilon\]
Let $f(n_1) = \epsilon_1$ where $n_1 > n_0$ and $\epsilon_1 < \epsilon$
\[f(n_1 + 2\pi k) - f(n_1) = ((n_1+2\pi k)^2-n_1^2)(sin(n_1) + 2) + 2\pi k\]
where $k \in n$
\[\lim_{k \to \infty}{f(n_1 + 2\pi k) - f(n_1)} \neq 0\]
\[\Rightarrow |f(n+2\pi k) - L| > \epsilon\]
for some $k > k_0$  where $k_0 \in n$\newline
That is, $\lim_{n \to \infty} {\frac{f(n)}{n^2}} $does not exists, therefore, the proposition is WRONG.

\subsection*{1-4 - all by myself}
\[lg(n) = 2lg(\sqrt{n}) = 2\frac{ln(\sqrt{n})}{\ln(2)}\]
Consider
\[\lim_{n \to \infty}{\frac{lg(n)}{\sqrt{n}}} = \lim_{n \to \infty}{\frac{2}{ln(2)}\frac{ln(\sqrt{n})}{\sqrt{n}}}\]
Let \(\sqrt{n} = x\)
\[\lim_{n \to \infty}{\frac{2}{ln(2)}\frac{ln(\sqrt{n})}{\sqrt{n}}} = \lim_{x \to \infty}{\frac{2}{ln(2)}\frac{ln(x)}{x}}\]
By L'Hopital's rule
\[\lim_{x \to \infty}{\frac{2}{ln(2)}\frac{ln(x)}{x}} = \lim_{x \to \infty}{\frac{2}{ln(2)}\frac{\frac{d}{dx}ln(x)}{\frac{d}{dx}x}} = \lim_{x \to \infty}{\frac{2}{ln(2)}\frac{\frac{1}{x}}{1}}=0 \in R\]
By conjecture 1, $lg(n) = O(\sqrt{n})$, QED

\subsection*{1-5 - all by myself}
Consider
\[\frac{\lim_{n \to \infty}{\Sigma_{i = 1}^{n}i^n}}{\lim_{n \to \infty}{\Sigma_{i = 1}^{n}n^n}} = \lim_{n \to \infty}{\Sigma_{i = 1}^{n}(\frac{i}{n})^n}\]
and
\[\lim_{n \to \infty}{\int^n_1(\frac{i}{n})^n di}\]
and
\[\lim_{n \to \infty}{\int^{n - 1}_0(\frac{i}{n})^n di}\]
By definition of $\Sigma$,
\[\lim_{n \to \infty}{\int^{n - 1}_0(\frac{i}{n})^n di}<\lim_{n \to \infty}{\Sigma_{i = 1}^{n}(\frac{i}{n})^n}<\lim_{n \to \infty}{\int^n_1(\frac{i}{n})^n di}\]
\[\lim_{n \to \infty}{\int^n_1(\frac{i}{n})^n di} = \lim_{n \to \infty}{\frac{1}{n^n}\int^n_1 i^n di} = \lim_{n \to \infty}{\frac{1}{n^n}\ \left[i^n\right]^n_1 }=\lim_{n \to \infty}{\frac{n^n}{n^n}}-\lim_{n \to \infty}{\frac{1^n}{n^n}}=1-0=1\]
\[\lim_{n \to \infty}{\int^{n-1}_0(\frac{i}{n})^n di} = \lim_{n \to \infty}{\frac{1}{n^n}\int^{n-1}_0 i^n di} = \lim_{n \to \infty}{\frac{1}{n^n}\ \left[i^n\right]^{n-1}_0 }=\lim_{n \to \infty}{\frac{(n-1)^n}{n^n}}-\lim_{n \to \infty}{\frac{1^n}{n^n}}=1-0=1\]
By squeeze theorem,
\[\lim_{n \to \infty}{\Sigma_{i = 1}^{n}(\frac{i}{n})^n} = 1\in R\]
By conjecture 1, ${\Sigma_{i = 1}^{n}i^n} = O(n^n)$

\subsection*{1-6 - all by myself}
In second last line, since $c$ can be positive or negative, it is possible that $\frac{1}{2^c}>2^c$ and therefore $f(n)> \frac{1}{2^c}$\newline
The correct proof:
\[|lg(f(n))-lg(g(n))|=c\Rightarrow lg(\frac{f(n)}{g(n)}) = c \Rightarrow\frac{f(n)}{g(n)}=2^c\]
\[\Rightarrow |lg(f(n))-lg(g(n))|=c\Rightarrow lg(\frac{f(n)}{g(n)}) = c_1 \Rightarrow\frac{f(n)}{g(n)}=2^{c_1}\]
where $c_1 = \pm c$\newline
Take $c' = 2^c-1$, we have $f(n)\leq c'g(n)$ for all $n > n_0$, QED\newpage

\section*{2. DSA Judge}
\subsection*{2-1}
ref: chatGPT\newline
psuedo code:
\begin{algorithmic}
    \Procedure{FindLost}{$A, n$}
    \For{i from 0 to 1}
    \State $m= n/2$
    \State $l = 0$
    \State $r = n$
    \While{$(r - l)$ > $1$}
    \If{$A[m] < m + (2-k)$}
    \State{$l = m$}
    \Else
    \State{$r = m$}
    \EndIf
    \EndWhile
    \EndFor
    \State {$max(r_1, r_2) += 1$}
    \State\Return $r_1, r_2$
    \EndProcedure
\end{algorithmic}
與binary sort相似，將$m$定為array的中心點，若$A[m]>m$，則代表在$m$的前面有資料遺失，將上界定為$m$，若否則將下界定為$m$，反覆迭代後資料遺失的位置會位於上界
Time complexity is almost the same as binary sort in worst case, the code will be run $lg(n)$ times, the time complexity $T(n) = O(lg(n))$
\newpage
\subsection*{2-2 - all by myself}
\begin{algorithmic}
    \Procedure{coupleDouble}{A,n}
    \State $isCouple = n - 1$
    \For{i from 0 to $n - 1$}
    \If{$A[isCouple] == 2*A[n - 1 - i]$}
    \State $A[isCouple] = 0$
    \State $A[n - 1 - i] = 0$
    \State $isCouple = isCouple-1$
    \While{$A[isCouple] == 0$}
    \State $isCouple = isCouple-1$
    \EndWhile
    \EndIf
    \EndFor
    \If{$isCouple == 0$}
    \State $return\ True$
    \Else
    \State $return\ False$
    \EndIf
    \EndProcedure
\end{algorithmic}
從$A[n-1]$遍歷到$A[0]$，$A[IsCouple]$代表"下一個遍歷到的數字，如果是配對中較小的一項，應該要與其配對的大項"，如果配對成功，就將兩數歸零，因此$A[IsCouple]$若遇到已配對的小項便會跳過，最後若$IsCouple=0$代表所有項皆配對成功，反之則否\newline
The for loops will run no more than $n$ times, so the time complexity is $O(n)$, and the space complexity is O(1)\newpage

\subsection*{2-3 - all by myself}
\begin{algorithmic}
    \Procedure{ReverselySort}{$root1, root2$}
    \If{$root1.ID < root2.ID$}
    \State $newNext = root1$
    \Else
    \State $newNext = root2$
    \EndIf
    \While{$root1.next\ or\ root2.next\ != NIL$}
    \If{$root2.ID < root1.ID$}
    \State $switch(root1, root2)$
    \EndIf
    \If{$root1.next != NIL$}
    \State $newPrev = *root1.next$
    \State $*root1.next = newNext$
    \State $newNext = root1$
    \State $root1 = newPrev$
    \Else
    \State $*root1.next = newNext$
    \State $newNext = root1$
    \While{$*root2.next != NIL$}
    \State $newPrev = *root2.next$
    \State $*root2.next = newNext$
    \State $newNext = root1$
    \State $root2 = newPrev$
    \EndWhile
    \EndIf
    \EndWhile
    \EndProcedure
\end{algorithmic}
比較兩個linked list中較小的項，先將該項原本的$next$存進$newPrev$避免下家遺失，並將該項的$next$指向$newNext$，再將較小的項指定為新的$newNext$，如此不斷迭代，而如果其中一條linked list已經全數存數新的list，就將剩下的list反轉\newline
The while loops will run no more than $n$ times, so the time complexity is $O(n)$, and the space complexity is O(1)

\newpage
\subsection*{2-4 - all by myself}
\begin{algorithmic}
    \Procedure{ReverselySort}{$node$}
    \While{$node.next != NIL$}
    \If{$node.a_i >= 0$}
    \State $*positiveTail.next = node$
    \State $positiveTail = node$
    \Else
    \State $*node.next = negativeHead$
    \State $negativeHead = node$
    \EndIf
    \EndWhile
    \State $*positiveTail.next = negativeHead$
    \EndProcedure
\end{algorithmic}
從head遍歷至tail，建立新的linked list，若遇到正數則將旗下家指向暫時設定的tail並暫時將其設為新的tail，若遇到負數則斷開連結並將下家指向目前遇到的最後一個負數，因為負數只會越來越大而正數只會越來越小，因此關係得以成立，最後再將最校的正數指向最大的負數\newline
The while loops will run no more than $n$ times, so the time complexity is $O(n)$, and the space complexity is O(1)

\newpage
\section*{Problem 3 - Stack / Queue}
\subsection*{3-1 - all by myself}
\[5\ 3\ 4\times+8\ 2\ 3+\times5\ 1\ 9\ 6\times+/--\]
Convert the operations of the highest priorty at first, such as those with parentheses, then put the operators of the second highest priorty behind it and put the addend(subtrahend, multiplicand, dividend) at the forefront, then the thrid priorty and so on.

\subsection*{3-2 - all by myself}
\[(5+2\times7)-((6\times3-4)-((4+8\times6)/4))\]
Traverse all the operators from left to right, and convert it into
\[the\ number\ in\ front\ of\ the\ front\ of\ it\  (the\ operator)\   the\ number\ in\ front\ of\ it\]

\subsection*{3-3 - all by myself}
Yes, we can move all elements to stack 2 and sort them to the ascending order by:\newline
\newline
Pop element 4 and push it to stack 2\newline
Pop element 1 and push it to stack 1\newline
Pop element 2 and push it to stack 1\newline
Pop element 3 and push it to stack 2\newline
Pop element 2 and push it to stack 2\newline
Pop element 1 and push it to stack 2\newline

\subsection*{3-4 - all by myself}
-Divide all the elements in stack 0 into $m$ groups in which all the elements is ascending or descending order\newline
-Then find the smallest elements $a_m$ of each group \newline
-For all $a_m$, if there are more than one $a$ with larger value on the top of it, it will be impossible to move all the elements to stack 2 and sort it in ascending order, otherwise, it will be possible.

\subsection*{3-5 - all by myself}
Each time when someone wants to park a bike, ze will park zer bike in the largest space, the first one will park between 0 and 10, the second one will park between 10 and 15.5, and the third one will park between 0 and 5 or 5 and 10\newline

\subsection*{3-6 - all by myself}
\begin{algorithmic}
    \Procedure{InsertBike}{$m, n, A$}
    \For{$i\ from\ 2\ to\ n$}
    \State $Enqueue(Q_1, A[i]-A[i-1])$
    \EndFor
    \State $Bike[0] = Q_1.head / 2$
    \State $Enqueue(Q_2, Q_1.head/2)$
    \State $Dequeue(Q_1)$
    \For{$i\ from\ 2\ to\ m$}
    \If{$Q_1.head > Q_2.head$ or $Q_1=NIL$}
    \State $Bike[i] = Bike[i-1] + Q_1.head / 2$
    \State $Enqueue(Q_2, Q_1.head/2)$
    \State $Dequeue(Q_1)$
    \Else
    \State $Bike[i] = Bike[i-1] + Q_2.head / 2$
    \State $Enqueue(Q_2, Q_2.head/2)$
    \State $Dequeue(Q_2)$
    \EndIf
    \EndFor
    \EndProcedure
\end{algorithmic}
Time complexity
\[T(m + n) = nd_2 + (n-1)d_3 + d_5 + d_6 + d_7 + md_8 + (m-1)d_9 + (m-1)(d_{10}+d_{11}+d_{12})\]
where $d_n$ is the time consumed by each line\newline
Take $c_1 = max((d_2 + d_3), (d_8 + d_9 + d_{10} + d_{11} + d_{12}))$ and $c_2 = d_5 + d_6 + d_7 - d_3 - d_9 - d_{10} - d_{11} - d_{12}$
\[T(m + n) = c_1(m + n) + c_2\]
for all $m \geq m_0$ and $n \geq n_0$, there exists
$c \geq c_1 + \frac{c_2}{m+n}$ such that \[T(m+n) \leq c(m+n)\]
\[\Rightarrow T(m + n) = O(m + n)\]
Space complexity\newline
array A: pointer size $s_1$\newline
integer m: size $s_2$\newline
integer n: size $s_2$\newline
array Bike: pointer size $s_1 +m\times$integer size $s_2$\newline
Queue $Q_1$: $n\times$pointer size $s_1+n\times$integer size $s_2$\newline
Queue $Q_2$: $m\times$pointer size $s_1+m\times$integer size $s_2$\newline
\[S(m+n) = (2+m+n)s_1 + (2+2m+n)s_2\]
Take $c = 2+2m+n$\newline
for all sets of $m,n$
\[c\geq 2+m+n\]
\[\Rightarrow S(m+n)\leq c(m+n) \Rightarrow S(m+n)=O(m+n)\]
QED
\end{document}